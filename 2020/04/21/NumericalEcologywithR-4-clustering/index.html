<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Neo Sans Intel:300,300italic,400,400italic,700,700italic|Times New Roman:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Helvetica:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"itsyunmeng.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="摘要： 聚类方法的介绍（以物种数据为例），包括基于连接的层次聚类、平均聚合聚类、ward最小方差聚类、灵活聚类、非层次聚类、多元回归树聚类、模糊聚类等。此外，还介绍了用环境数据进行比较，以及物种集合（如何对物种进行分组）。">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记_数量生态学_4.聚类分析">
<meta property="og:url" content="https://itsyunmeng.github.io/2020/04/21/NumericalEcologywithR-4-clustering/index.html">
<meta property="og:site_name" content="Yunmeng&#39;s Blog">
<meta property="og:description" content="摘要： 聚类方法的介绍（以物种数据为例），包括基于连接的层次聚类、平均聚合聚类、ward最小方差聚类、灵活聚类、非层次聚类、多元回归树聚类、模糊聚类等。此外，还介绍了用环境数据进行比较，以及物种集合（如何对物种进行分组）。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/1.single.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/2.complete.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/3.UPGMA.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/4.WPGMA.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/5.UPGMC.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/6.WPGMC.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/7.ward.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/8.sqrt.ward.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/9.shepard.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/10.fusionlevelvalue.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/11.sihouette.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/12.mantel.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/13.finalsilhouette.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/14.finaldendrogram0.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/15.finaldendrogram.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/16.spatialcluster.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/17.heatmapcluster.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/18.pheatmap2.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/19.kmeans.ssi.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/22.spatial.kmeans.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/20.pam.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/21.kmeanspam.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/23.envboxplot.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/24.kmeansclusters.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/25.CVRE.jpg">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/26.MRT.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/27.spatial.mrt.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/28.fuzzy.silhouette.png">
<meta property="og:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/29.fuzzy.pcoa.png">
<meta property="article:published_time" content="2020-04-21T13:51:17.000Z">
<meta property="article:modified_time" content="2020-08-12T14:19:58.482Z">
<meta property="article:author" content="Yunmeng">
<meta property="article:tag" content="R">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/1.single.png">

<link rel="canonical" href="https://itsyunmeng.github.io/2020/04/21/NumericalEcologywithR-4-clustering/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>笔记_数量生态学_4.聚类分析 | Yunmeng's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yunmeng's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://itsyunmeng.github.io/2020/04/21/NumericalEcologywithR-4-clustering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yunmeng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yunmeng's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          笔记_数量生态学_4.聚类分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-21 15:51:17" itemprop="dateCreated datePublished" datetime="2020-04-21T15:51:17+02:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-12 16:19:58" itemprop="dateModified" datetime="2020-08-12T16:19:58+02:00">2020-08-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Statistics-and-Analysis/" itemprop="url" rel="index"><span itemprop="name">Statistics and Analysis</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Statistics-and-Analysis/R/" itemprop="url" rel="index"><span itemprop="name">R</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>摘要：</strong> 聚类方法的介绍（以物种数据为例），包括基于连接的层次聚类、平均聚合聚类、ward最小方差聚类、灵活聚类、非层次聚类、多元回归树聚类、模糊聚类等。此外，还介绍了用环境数据进行比较，以及物种集合（如何对物种进行分组）。</p>
<a id="more"></a>
<h1>目标</h1>
<ul>
<li>学习如何选择合适的聚类方法</li>
<li>使用不同的聚类方法分析Doubs数据集，确认样方组和鱼类物种组</li>
<li>学习一种强大的模型方法：约束聚类（constrained clustering)，一种被外部数据集约束聚类过程的方法。</li>
</ul>
<h1>聚类概述</h1>
<p>不同类型的聚类方法：</p>
<ul>
<li>连续（sequential）或同步（simultaneous）</li>
<li>聚合（agglomerative）或分划（divisive）</li>
<li>单元（monothetic）和多元（polythetic）</li>
<li>层次法（hierarchical）和非层次法（non-hierarchical）</li>
<li>概率法（probabistic）和非概率法（non-probabistic）</li>
</ul>
<p>使用Doubs数据集进行演示<br>
预处理</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#load</span> packages</span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(ade4)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(vegan)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(gclus)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(cluster)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(RColorBrewer)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(labdsv)</span></span></span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(mvpart)</span></span> <span class="selector-id">#devtools</span>::install_github(<span class="string">"cran/mvpart"</span>)</span><br><span class="line"><span class="function"><span class="title">library</span><span class="params">(MVPARTwrap)</span></span> <span class="selector-id">#devtools</span>::install_github(<span class="string">"cran/MVPARTwrap"</span>)</span><br><span class="line"><span class="selector-id">#import</span> data</span><br><span class="line">spe &lt;- read.csv(<span class="string">"DoubsSpe.csv"</span>, row.names=<span class="number">1</span>)</span><br><span class="line">env &lt;- read.csv(<span class="string">"DoubsEnv.csv"</span>, row.names=<span class="number">1</span>)</span><br><span class="line">spa &lt;- read.csv(<span class="string">"DoubsSpa.csv"</span>, row.names=<span class="number">1</span>)</span><br><span class="line"><span class="selector-id">#delete</span> sampling site <span class="number">8</span></span><br><span class="line">spe &lt;- spe[-<span class="number">8</span>,]</span><br><span class="line">env &lt;- env[-<span class="number">8</span>,]</span><br><span class="line">spa &lt;- spa[-<span class="number">8</span>,]</span><br></pre></td></tr></table></figure>
<h1>基于连接的层次聚类</h1>
<h2 id="单连接聚合聚类">单连接聚合聚类</h2>
<p>依据 <strong>最短的成对距离</strong>：一对对象连接第三个对象，成为新的一组，再连接另外一个对象，直到全部对象被连接完毕为止。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spe</span>.<span class="keyword">norm</span> &lt;- decostand(<span class="keyword">spe</span>, <span class="string">"normalize"</span>)</span><br><span class="line"><span class="keyword">spe</span>.ch &lt;- vegdist(<span class="keyword">spe</span>.<span class="keyword">norm</span>, <span class="string">"euc"</span>) #弦距离矩阵；equal <span class="keyword">to</span> <span class="keyword">spe</span>.ch&lt;-dist(<span class="keyword">spe</span>.<span class="keyword">norm</span>)</span><br><span class="line"><span class="keyword">spe</span>.ch.single &lt;- hclust(<span class="keyword">spe</span>.ch, method=<span class="string">"single"</span>)</span><br><span class="line">plot(<span class="keyword">spe</span>.ch.single,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"single linkage agglomerative clustering"</span>)</span><br></pre></td></tr></table></figure>
<p>1.single<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/1.single.png" alt="1"></p>
<h2 id="完全连接聚合聚类">完全连接聚合聚类</h2>
<p>依据 <strong>最远的距离对</strong>：比较与组内所有成员与备选新成员形成的对象对最远的距离。<br>
相比于单连接，<u>完全连接更适于寻找和识别数据的间断分布</u>。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spe.ch.complete &lt;- hclust(spe.ch, <span class="function"><span class="keyword">method</span>="<span class="title">complete</span>")</span></span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.complete,main="Cluster Dendrogram",ylab="height",xlab="complete linkage agglomerative clustering")</span></span></span><br></pre></td></tr></table></figure>
<p>2.complete<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/2.complete.png" alt="2"></p>
<h1>平均聚合聚类</h1>
<p>基于对象间平均相异性或聚类簇形心的聚类方法。<br>
包括四类（最常用 <strong>UPGMA</strong>，UPGMC和WPGMC易发生翻转）：</p>
<ul>
<li>使用算术平均的非权重成对组法（UPGMA，‘average’)：算术平均，等权重；</li>
<li>使用算术平均的权重成对组法（WPGMA，‘mcquitty’)：算术平均，不等权重；</li>
<li>使用形心的非权重成对组法（UPGMC，‘centroid’)：形心聚类，等权重；</li>
<li>使用形心的权重成对组法（WPGMC，‘median’)：形心聚类，不等权重；</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span> &lt;- hclust(spe<span class="selector-class">.ch</span>, method=<span class="string">"average"</span>)#UPGMA</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.UPGMA,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"UPGMA agglomerative clustering"</span>)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.WPGMA</span> &lt;- hclust(spe<span class="selector-class">.ch</span>, method=<span class="string">"mcquitty"</span>)#WPGMA</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.WPGMA,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"WPGMA agglomerative clustering"</span>)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.centroid</span> &lt;- hclust(spe<span class="selector-class">.ch</span>, method=<span class="string">"centroid"</span>)#UPGMC</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.centroid,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"UPGMC agglomerative clustering"</span>)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.WPGMC</span> &lt;- hclust(spe<span class="selector-class">.ch</span>, method=<span class="string">"median"</span>)#WPGMC</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.WPGMC,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"WPGMC agglomerative clustering"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>3.UPGMA<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/3.UPGMA.png" alt="3"><br>
4.WPGMA<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/4.WPGMA.png" alt="4"><br>
5.UPGMC<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/5.UPGMC.png" alt="5"><br>
6.WPGMC<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/6.WPGMC.png" alt="6"></p>
<h1>Ward最小方差聚类</h1>
<p>基于最小二乘法线性模型准则的聚类方法，分组的依据是使组内平方和（即方差分析的方差）最小化。<br>
注意：虽然组内平方和的计算是基于欧氏模型，但ward聚类并不要求输入的数据一定是欧氏距离矩阵。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.ward</span> &lt;- hclust(spe<span class="selector-class">.ch</span>, method=<span class="string">"ward.D"</span>)</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.ward,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"Ward clustering"</span>)</span></span></span><br><span class="line">#使用距离平方造成此聚类树上半部分过于膨胀。为了使聚类树比例看起来更协调而不影响其拓扑结构，可以使用当前融合水平的平方根重新绘图。</span><br><span class="line">spe<span class="selector-class">.ch</span>.ward<span class="variable">$height</span> &lt;- sqrt(spe<span class="selector-class">.ch</span>.ward<span class="variable">$height</span>)</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(spe.ch.ward,main=<span class="string">"Cluster Dendrogram"</span>,ylab=<span class="string">"height"</span>,xlab=<span class="string">"Ward clustering"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>7.ward<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/7.ward.png" alt="7"><br>
8.sqrt.ward<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/8.sqrt.ward.png" alt="8"></p>
<h1>灵活聚类</h1>
<p>cluster程序包内的agnes()函数通过参数method和par.method的设置可以实现灵活聚类。</p>
<h1>解读和比较层次聚类结果</h1>
<h2 id="引言">引言</h2>
<p>聚类分析是一种探索性分析，而非统计检验。影响其结果的因素包括聚类方法本身和用于聚类分析的关联系数的选择。</p>
<h2 id="同表型相关">同表型相关</h2>
<p>=&gt; 两个对象交汇节点所在的层次水平即是两个对象 <strong>同表型距离</strong>。<br>
<strong>同表型相关（cophenetic correlation）</strong> 是原始的距离矩阵和同表型距离矩阵之间的<u>perason相关系数，也可以用spearman或kendall秩相关系数</u>。<br>
<strong>具有最高的同表型相关系数的聚类方法可视为原始矩阵最好的聚类模型。</strong><br>
=&gt; 另一个比较聚类结果的指标是 <strong>Gower</strong>。它等于原始距离与同表型距离之间差值的平方和。<br>
<strong>具有最小Gower距离的聚类方法也可视为原始矩阵最好的聚类模型。</strong><br>
<u>注意：同表型相关系数和Gower距离分析结果并不总是一致。</u></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#同表型相关系数</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.single</span><span class="selector-class">.coph</span> &lt;- cophenetic(spe<span class="selector-class">.ch</span>.single)#同表型矩阵</span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(spe.ch, spe.ch.single.coph)</span></span>#同表型相关，默认pearson</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.comp</span><span class="selector-class">.coph</span> &lt;- cophenetic(spe<span class="selector-class">.ch</span>.complete)</span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(spe.ch, spe.ch.comp.coph)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span><span class="selector-class">.coph</span> &lt;- cophenetic(spe<span class="selector-class">.ch</span>.UPGMA)</span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(spe.ch, spe.ch.UPGMA.coph)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.ward</span><span class="selector-class">.coph</span> &lt;- cophenetic(spe<span class="selector-class">.ch</span>.ward)</span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(spe.ch, spe.ch.ward.coph)</span></span></span><br><span class="line"><span class="function"><span class="title">cor</span><span class="params">(spe.ch, spe.ch.ward.coph, method=<span class="string">"spearman"</span>)</span></span></span><br><span class="line">#同表型相关系数的可视化: Shepard图</span><br><span class="line"><span class="function"><span class="title">par</span><span class="params">(mfrow=c(<span class="number">2</span>,<span class="number">2</span>)</span></span>)</span><br><span class="line">plot(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.single</span><span class="selector-class">.coph</span>, xlab=<span class="string">"Chord distance"</span>,</span><br><span class="line">  ylab=<span class="string">"Cophenetic distance"</span>, asp=<span class="number">1</span>, xlim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)), ylim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)),</span><br><span class="line">  main=c(<span class="string">"Single linkage"</span>,paste(<span class="string">"Cophenetic correlation"</span>,</span><br><span class="line">  round(cor(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.single</span>.coph),<span class="number">3</span>))))</span><br><span class="line"><span class="function"><span class="title">abline</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">lines</span><span class="params">(lowess(spe.ch, spe.ch.single.coph)</span></span>, col=<span class="string">"red"</span>)</span><br><span class="line">plot(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.comp</span><span class="selector-class">.coph</span>, xlab=<span class="string">"Chord distance"</span>,</span><br><span class="line">	ylab=<span class="string">"Cophenetic distance"</span>, asp=<span class="number">1</span>, xlim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)), ylim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)),</span><br><span class="line">  main=c(<span class="string">"Complete linkage"</span>, paste(<span class="string">"Cophenetic correlation"</span>,</span><br><span class="line">  round(cor(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.comp</span>.coph),<span class="number">3</span>))))</span><br><span class="line"><span class="function"><span class="title">abline</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">lines</span><span class="params">(lowess(spe.ch, spe.ch.comp.coph)</span></span>, col=<span class="string">"red"</span>)</span><br><span class="line">plot(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span><span class="selector-class">.coph</span>, xlab=<span class="string">"Chord distance"</span>,</span><br><span class="line">	ylab=<span class="string">"Cophenetic distance"</span>, asp=<span class="number">1</span>, xlim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)), ylim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)),</span><br><span class="line">  main=c(<span class="string">"UPGMA"</span>, paste(<span class="string">"Cophenetic correlation"</span>,</span><br><span class="line">  round(cor(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span>.coph),<span class="number">3</span>))))</span><br><span class="line"><span class="function"><span class="title">abline</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">lines</span><span class="params">(lowess(spe.ch, spe.ch.UPGMA.coph)</span></span>, col=<span class="string">"red"</span>)</span><br><span class="line">plot(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.ward</span><span class="selector-class">.coph</span>, xlab=<span class="string">"Chord distance"</span>,</span><br><span class="line">	ylab=<span class="string">"Cophenetic distance"</span>, asp=<span class="number">1</span>, xlim=c(<span class="number">0</span>,sqrt(<span class="number">2</span>)),</span><br><span class="line">  ylim=c(<span class="number">0</span>,max(spe<span class="selector-class">.ch</span>.ward<span class="variable">$height</span>)),</span><br><span class="line">  main=c(<span class="string">"Ward clustering"</span>, paste(<span class="string">"Cophenetic correlation"</span>,</span><br><span class="line">  round(cor(spe<span class="selector-class">.ch</span>, spe<span class="selector-class">.ch</span><span class="selector-class">.ward</span>.coph),<span class="number">3</span>))))</span><br><span class="line"><span class="function"><span class="title">abline</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">lines</span><span class="params">(lowess(spe.ch, spe.ch.ward.coph)</span></span>, col=<span class="string">"red"</span>)</span><br></pre></td></tr></table></figure>
<p>9.shepard<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/9.shepard.png" alt="9"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#Gower</span>距离</span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.single</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">sum</span>((<span class="selector-tag">spe</span><span class="selector-class">.ch-spe</span><span class="selector-class">.ch</span><span class="selector-class">.single</span><span class="selector-class">.coph</span>)^2)</span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.comp</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">sum</span>((<span class="selector-tag">spe</span><span class="selector-class">.ch-spe</span><span class="selector-class">.ch</span><span class="selector-class">.comp</span><span class="selector-class">.coph</span>)^2)</span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.UPGMA</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">sum</span>((<span class="selector-tag">spe</span><span class="selector-class">.ch-spe</span><span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span><span class="selector-class">.coph</span>)^2)</span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.ward</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">sum</span>((<span class="selector-tag">spe</span><span class="selector-class">.ch-spe</span><span class="selector-class">.ch</span><span class="selector-class">.ward</span><span class="selector-class">.coph</span>)^2)</span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.single</span></span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.comp</span></span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.UPGMA</span></span><br><span class="line"><span class="selector-tag">gow</span><span class="selector-class">.dist</span><span class="selector-class">.ward</span></span><br></pre></td></tr></table></figure>
<h2 id="寻找可解读的聚类簇">寻找可解读的聚类簇</h2>
<p>可以对聚类树进行裁剪，裁剪到那个水平可以通过视觉判断，也可以通过满足一些标准来确定:</p>
<ul>
<li>融合水平值（fusion level value）：聚类树中两个分支融合处的相异性的数值；</li>
<li>轮廓宽度（silhouette width）：一个对象同同一组内其他对象的平均距离与该对象同最邻近聚类簇内所有对象的平均距离的比较，范围-1到1;</li>
<li>距离矩阵和代表分组的二元矩阵的比较：计算原始距离与代表不同分类水平的二元矩阵之间的相关性，然后选择最高的相关（mantel相关）系数所对应的分类水平作为最优分组方案。</li>
</ul>
<p>可视化</p>
<ul>
<li>最终分组的轮廓图：确定了分组数和相关的聚类方法之后，用此确定这样分组是否真的合理（即没有或极少的对象被分到不合适的组里）。</li>
<li>利用绘图工具修饰的最终聚类树</li>
<li>聚类结果空间分布图</li>
<li>热图和排序的群落表</li>
</ul>
<h3 id="融合水平值图">融合水平值图</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">par(<span class="attribute">mfrow</span>=c(2,2))</span><br><span class="line">summary(spe.ch.single)</span><br><span class="line">plot(spe.ch.single<span class="variable">$height</span>, nrow(spe):2, <span class="attribute">type</span>=<span class="string">"S"</span>, <span class="attribute">main</span>=<span class="string">"Fusion levels - Chord - Single"</span>, <span class="attribute">ylab</span>=<span class="string">"k (number of clusters)"</span>, <span class="attribute">xlab</span>=<span class="string">"h (node height)"</span>, <span class="attribute">col</span>=<span class="string">"grey"</span>)</span><br><span class="line">text(spe.ch.single<span class="variable">$height</span>, nrow(spe):2, nrow(spe):2, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=0.5)</span><br><span class="line">plot(spe.ch.complete<span class="variable">$height</span>, nrow(spe):2, <span class="attribute">type</span>=<span class="string">"S"</span>, <span class="attribute">main</span>=<span class="string">"Fusion levels - Chord - Complete"</span>, <span class="attribute">ylab</span>=<span class="string">"k (number of clusters)"</span>, <span class="attribute">xlab</span>=<span class="string">"h (node height)"</span>, <span class="attribute">col</span>=<span class="string">"grey"</span>)</span><br><span class="line">text(spe.ch.complete<span class="variable">$height</span>, nrow(spe):2, nrow(spe):2, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=0.5)</span><br><span class="line">plot(spe.ch.UPGMA<span class="variable">$height</span>, nrow(spe):2, <span class="attribute">type</span>=<span class="string">"S"</span>, <span class="attribute">main</span>=<span class="string">"Fusion levels - Chord - UPGMA"</span>, <span class="attribute">ylab</span>=<span class="string">"k (number of clusters)"</span>, <span class="attribute">xlab</span>=<span class="string">"h (node height)"</span>, <span class="attribute">col</span>=<span class="string">"grey"</span>)</span><br><span class="line">text(spe.ch.UPGMA<span class="variable">$height</span>, nrow(spe):2, nrow(spe):2, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=0.5)</span><br><span class="line">plot(spe.ch.ward<span class="variable">$height</span>, nrow(spe):2, <span class="attribute">type</span>=<span class="string">"S"</span>, <span class="attribute">main</span>=<span class="string">"Fusion levels - Chord - Ward"</span>, <span class="attribute">ylab</span>=<span class="string">"k (number of clusters)"</span>, <span class="attribute">xlab</span>=<span class="string">"h (node height)"</span>, <span class="attribute">col</span>=<span class="string">"grey"</span>)</span><br><span class="line">text(spe.ch.ward<span class="variable">$height</span>, nrow(spe):2, nrow(spe):2, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=0.5)</span><br></pre></td></tr></table></figure>
<p>10.fusionlevelvalue<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/10.fusionlevelvalue.png" alt="10"></p>
<p>使用<code>cutree()函数</code>设定分类组的数量，并使用列联表比较分类组的差异。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#裁剪聚类树以获得<span class="selector-tag">k</span>个分类组并使用列联表比较组之间的差异</span><br><span class="line"><span class="selector-tag">k</span> &lt;<span class="selector-tag">-</span> 4#从融合水平值图可以观察到分4组水平在所有图里有小的跳跃</span><br><span class="line"><span class="selector-tag">spebc</span><span class="selector-class">.single</span><span class="selector-class">.g</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">cutree</span>(<span class="selector-tag">spe</span><span class="selector-class">.ch</span><span class="selector-class">.single</span>, <span class="selector-tag">k</span>)#裁剪聚类树</span><br><span class="line"><span class="selector-tag">spebc</span><span class="selector-class">.complete</span><span class="selector-class">.g</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">cutree</span>(<span class="selector-tag">spe</span><span class="selector-class">.ch</span><span class="selector-class">.complete</span>, <span class="selector-tag">k</span>)</span><br><span class="line"><span class="selector-tag">spebc</span><span class="selector-class">.UPGMA</span><span class="selector-class">.g</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">cutree</span>(<span class="selector-tag">spe</span><span class="selector-class">.ch</span><span class="selector-class">.UPGMA</span>, <span class="selector-tag">k</span>)</span><br><span class="line"><span class="selector-tag">spebc</span><span class="selector-class">.ward</span><span class="selector-class">.g</span> &lt;<span class="selector-tag">-</span> <span class="selector-tag">cutree</span>(<span class="selector-tag">spe</span><span class="selector-class">.ch</span><span class="selector-class">.ward</span>, <span class="selector-tag">k</span>)</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.single</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.complete</span><span class="selector-class">.g</span>)#通过列联表比较分类结果。如果两个聚类的结果完全一样，那么这个列联表每行和每列只有一个非零数字，其他应该为0.</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.single</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.UPGMA</span><span class="selector-class">.g</span>)</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.single</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.ward</span><span class="selector-class">.g</span>)#解读：单连接聚类第二组有26个样方，这些样方在<span class="selector-tag">ward</span>聚类中被分散到4个组里。</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.complete</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.UPGMA</span><span class="selector-class">.g</span>)</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.complete</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.ward</span><span class="selector-class">.g</span>)</span><br><span class="line"><span class="selector-tag">table</span>(<span class="selector-tag">spebc</span><span class="selector-class">.UPGMA</span><span class="selector-class">.g</span>, <span class="selector-tag">spebc</span><span class="selector-class">.ward</span><span class="selector-class">.g</span>)</span><br></pre></td></tr></table></figure>
<h3 id="轮廓宽度图">轮廓宽度图</h3>
<p>轮廓宽度值越大，对象聚类越好，负值意味着该对象有可能被错分到当前聚类簇内。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">asw &lt;- numeric(nrow(spe))#创建指定长度的双精度向量，每个元素等于0.</span><br><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> 2:(nrow(spe)-1)) &#123;</span><br><span class="line">	sil &lt;- silhouette(cutree(spe.ch.ward, <span class="attribute">k</span>=k), spe.ch)</span><br><span class="line">	asw[k] &lt;- summary(sil)<span class="variable">$avg</span>.width</span><br><span class="line">	&#125;</span><br><span class="line">k.best &lt;- which.max(asw)#选择最佳（最大）轮廓宽度值的分组数</span><br><span class="line">plot(1:nrow(spe), asw, <span class="attribute">type</span>=<span class="string">"h"</span>,</span><br><span class="line">  <span class="attribute">main</span>=<span class="string">"Silhouette-optimal number of clusters, Ward"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"k (number of groups)"</span>, <span class="attribute">ylab</span>=<span class="string">"Average silhouette width"</span>)</span><br><span class="line">axis(1, k.best, paste(<span class="string">"optimum"</span>,k.best,<span class="attribute">sep</span>=<span class="string">"\n"</span>), <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">font</span>=2,</span><br><span class="line">  col.<span class="attribute">axis</span>=<span class="string">"red"</span>)</span><br><span class="line">points(k.best, max(asw), <span class="attribute">pch</span>=16, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=1.5)</span><br><span class="line">cat(<span class="string">""</span>, <span class="string">"Silhouette-optimal number of clusters k ="</span>, k.best, <span class="string">"\n"</span>,</span><br><span class="line">	<span class="string">"with an average silhouette width of"</span>, max(asw), <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">####不一定推算出来的分组值就是适合的，还要考虑到生态学的意义等。</span></span><br></pre></td></tr></table></figure>
<p>11.sihouette<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/11.sihouette.png" alt="11"></p>
<h3 id="距离矩阵和代表分组的二元矩阵的比较">距离矩阵和代表分组的二元矩阵的比较</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编写计算代表分类水平的二元距离矩阵的函数</span></span><br><span class="line">grpdist &lt;- function(X)</span><br><span class="line">  &#123;</span><br><span class="line">  require(cluster)</span><br><span class="line">  gr &lt;- as.data.frame(as.factor(X))</span><br><span class="line">  distgr &lt;- daisy(gr, <span class="string">"gower"</span>)</span><br><span class="line">  distgr</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">#基于ward聚类结果运行该函数</span></span><br><span class="line">kt &lt;- data.frame(<span class="attribute">k</span>=1:nrow(spe), <span class="attribute">r</span>=0)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 2:(nrow(spe)-1)) &#123;</span><br><span class="line">	gr &lt;- cutree(spe.ch.ward, i)</span><br><span class="line">	distgr &lt;- grpdist(gr)</span><br><span class="line">	mt &lt;- cor(spe.ch, distgr, <span class="attribute">method</span>=<span class="string">"pearson"</span>)</span><br><span class="line">	kt[i,2] &lt;- mt</span><br><span class="line">&#125;</span><br><span class="line">kt</span><br><span class="line">k.best &lt;- which.max(kt<span class="variable">$r</span>)</span><br><span class="line"><span class="comment">#通过cluster程序包内plot.silhouette函数绘制分析图</span></span><br><span class="line">plot(kt<span class="variable">$k</span>, kt<span class="variable">$r</span>, <span class="attribute">type</span>=<span class="string">"h"</span>, <span class="attribute">main</span>=<span class="string">"Mantel-optimal number of clusters-Ward"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"k (number of groups)"</span>, <span class="attribute">ylab</span>=<span class="string">"Pearson's correlation"</span>)</span><br><span class="line">axis(1, k.best, paste(<span class="string">"optimum"</span>, k.best, <span class="attribute">sep</span>=<span class="string">"\n"</span>), <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">font</span>=2,</span><br><span class="line">	col.<span class="attribute">axis</span>=<span class="string">"red"</span>)</span><br><span class="line">points(k.best, max(kt<span class="variable">$r</span>), <span class="attribute">pch</span>=16, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=1.5)</span><br></pre></td></tr></table></figure>
<p>12.mantel<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/12.mantel.png" alt="12"></p>
<h3 id="最终分组的轮廓图">最终分组的轮廓图</h3>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">k &lt;- <span class="number">4</span></span><br><span class="line">cutg &lt;- cutree(spe.ch.ward, k=k)#裁剪聚类树,进行分组</span><br><span class="line">sil &lt;- silhouette(cutg, spe.ch)#计算轮廓宽度</span><br><span class="line">silo &lt;- sortSilhouette(sil)#轮廓宽度降序排列</span><br><span class="line">rownames(silo) &lt;- row.names(spe)[attr(silo,<span class="string">"iOrd"</span>)]#指定行名</span><br><span class="line">plot(silo, main=<span class="string">"Silhouette plot - Chord - Ward"</span>,</span><br><span class="line">	cex.names=<span class="number">0.8</span>, col=cutg+<span class="number">1</span>, nmax.lab=<span class="number">100</span>,border=<span class="string">"white"</span></span><br><span class="line">) #组<span class="number">1</span>和组<span class="number">3</span>最连贯，而组<span class="number">2</span>可能含有被错分的对象。</span><br></pre></td></tr></table></figure>
<p>13.finalsilhouette<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/13.finalsilhouette.png" alt="13"></p>
<h3 id="利用绘图工具修饰的最终聚类树">利用绘图工具修饰的最终聚类树</h3>
<p><code>reorder.hclust()</code>的作用是重新排列从函数hclust()获得的聚类树，使聚类树内对象的排列顺序与原始矩阵内对象的排列顺序尽可能一致。重排不影响聚类树的结构。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spe.chwo &lt;- reorder.hclust(spe.ch.ward, spe.ch)</span><br><span class="line"><span class="comment">#hang=-1，设定聚类树的开端从0开始。</span></span><br><span class="line">plot(spe.chwo, <span class="attribute">hang</span>=-1, <span class="attribute">xlab</span>=<span class="string">"4 groups"</span>, <span class="attribute">sub</span>=<span class="string">""</span>, <span class="attribute">ylab</span>=<span class="string">"Height"</span>,</span><br><span class="line">	<span class="attribute">main</span>=<span class="string">"Chord - Ward (reordered)"</span>)</span><br><span class="line">rect.hclust(spe.chwo, <span class="attribute">k</span>=4)#为聚类簇加框</span><br><span class="line"></span><br><span class="line">source(<span class="string">"hcoplot.R"</span>)</span><br><span class="line">hcoplot(spe.ch.ward, spe.ch, <span class="attribute">k</span>=4)</span><br></pre></td></tr></table></figure>
<p>14.finaldendrogram0<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/14.finaldendrogram0.png" alt="14"><br>
15.finaldendrogram<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/15.finaldendrogram.png" alt="15"></p>
<h3 id="聚类结果空间分布图">聚类结果空间分布图</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plot(spa, <span class="attribute">asp</span>=1, <span class="attribute">type</span>=<span class="string">"n"</span>, <span class="attribute">main</span>=<span class="string">"Four Ward groups"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"x coordinate (km)"</span>, <span class="attribute">ylab</span>=<span class="string">"y coordinate (km)"</span>)</span><br><span class="line">lines(spa, <span class="attribute">col</span>=<span class="string">"light blue"</span>)</span><br><span class="line">text(50, 10, <span class="string">"Upstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line">text(15, 115, <span class="string">"Downstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line"><span class="comment">####添加4组分类信息</span></span><br><span class="line">grw &lt;- spebc.ward.g</span><br><span class="line">k &lt;- length(levels(factor(grw)))#4</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1:k) &#123;</span><br><span class="line">   points(spa[<span class="attribute">grw</span>==i,1], spa[<span class="attribute">grw</span>==i,2], <span class="attribute">pch</span>=i+20, <span class="attribute">cex</span>=2, <span class="attribute">col</span>=i+1, <span class="attribute">bg</span>=i+1)</span><br><span class="line">   &#125;</span><br><span class="line">text(spa, row.names(spa), <span class="attribute">cex</span>=0.8, <span class="attribute">col</span>=<span class="string">"white"</span>, <span class="attribute">font</span>=2)</span><br><span class="line">legend(<span class="string">"bottomright"</span>, paste(<span class="string">"Group"</span>,1:k), pch=(1:k)+20, <span class="attribute">col</span>=2:(k+1),</span><br><span class="line">  pt.<span class="attribute">bg</span>=2:(k+1), pt.<span class="attribute">cex</span>=1.5, <span class="attribute">bty</span>=<span class="string">"n"</span>)</span><br></pre></td></tr></table></figure>
<p>16.spatialcluster<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/16.spatialcluster.png" alt="16"></p>
<h3 id="热图和排序的群落表">热图和排序的群落表</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dend &lt;- as.dendrogram(spe.chwo)</span><br><span class="line">heatmap(as.matrix(spe.ch), <span class="attribute">Rowv</span>=dend, <span class="attribute">symm</span>=<span class="literal">TRUE</span>, <span class="attribute">margin</span>=c(3,3), <span class="attribute">col</span>=colorRampPalette(c("black","red"))(30))#弦距离矩阵。Rowv表示对行进行重排；symm=T表示对称；margin表示行名和列名的边距。</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> &lt;- vegemite(spe, spe.chwo)#物种按照在样方得分加权平均进行排列</span><br><span class="line">heatmap(t(spe[rev(<span class="keyword">or</span><span class="variable">$species</span>)]), <span class="attribute">Rowv</span>=NA, <span class="attribute">Colv</span>=dend,</span><br><span class="line">	<span class="attribute">col</span>=c("white", brewer.pal(5,<span class="string">"Greens"</span>)), <span class="attribute">scale</span>=<span class="string">"none"</span>, <span class="attribute">margin</span>=c(4,4),</span><br><span class="line">	<span class="attribute">ylab</span>=<span class="string">"Species (weighted averages of sites)"</span>, <span class="attribute">xlab</span>=<span class="string">"Sites"</span>)#scale="none"表示不进行缩放</span><br></pre></td></tr></table></figure>
<p>17.heatmapcluster<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/17.heatmapcluster.png" alt="17"><br>
18.pheatmap2<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/18.pheatmap2.png" alt="18"></p>
<h1>非层次聚类</h1>
<ul>
<li>分组的依据：尽量使组内的对象之间比组间对象之间的相似性更高。</li>
<li>两种非层次聚类方法： <strong>k-means partitioning（k-均值划分）</strong> 和 <strong>partitioning around medoids（围绕中心点划分,PAM）</strong>。</li>
<li>注意：<u>不同量纲的变量在进行非层次聚类之前应该进行标准化，因为方差的量纲等于变量量纲的平方，如果不标准化，方差无意义。</u></li>
</ul>
<h2 id="k-均值划分">k-均值划分</h2>
<p>k-means划分是一种线性方法，不适合含有很多零值的原始数据。但有一个解决办法，<strong>数据预转化</strong>。此处使用范数标准化的物种数据spe.norm进行演示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spe<span class="selector-class">.kmeans</span> &lt;- kmeans(spe<span class="selector-class">.norm</span>, centers=<span class="number">4</span>, nstart=<span class="number">100</span>)#centers=k，结合上述研究，此处使用<span class="number">4</span>.</span><br><span class="line"><span class="function"><span class="title">table</span><span class="params">(spe.kmeans<span class="variable">$cluster</span>, spebc.ward.g)</span></span> #当前的结果与之前ward聚类结果比较</span><br></pre></td></tr></table></figure>
<p>kmeans()函数每次只能产生一个简单的预先设定组数的分组结果。但是多少组是最好的分类方案呢？可从以下两个指标进行评判：</p>
<ul>
<li>最大化Calinski-Harabasz指数</li>
<li>ssi（简单结构指数simple structure index）</li>
</ul>
<p>示例：k均值划分，2组到10组</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spe.KM.cascade &lt;- cascadeKM(spe.norm, inf.<span class="attribute">gr</span>=2, sup.<span class="attribute">gr</span>=10, <span class="attribute">iter</span>=100,</span><br><span class="line">  <span class="attribute">criterion</span>=<span class="string">"ssi"</span>) #也可在criterion中选择<span class="string">"calinski"</span>方法</span><br><span class="line">plot(spe.KM.cascade, <span class="attribute">sortg</span>=<span class="literal">TRUE</span>,border="white")#sortg=T表示每个聚类簇内按照对象之间紧密程度重新排列对象。</span><br><span class="line">summary(spe.KM.cascade)</span><br><span class="line">spe.KM.cascade<span class="variable">$results</span>#最大ssi组数为最佳组数</span><br><span class="line">spe.KM.cascade<span class="variable">$partition</span>#不同分组数中各样方的归属</span><br><span class="line">spe[order(spe.kmeans<span class="variable">$cluster</span>),]#按照k-均值划分结果重新排列样方</span><br><span class="line">ord.KM &lt;- vegemite(spe, spe.kmeans<span class="variable">$cluster</span>)#使用函数vegemite()重新排列样方-物种矩阵</span><br><span class="line">spe[ord.KM<span class="variable">$sites</span>, ord.KM<span class="variable">$species</span>]</span><br></pre></td></tr></table></figure>
<p>19.kmeans.ssi<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/19.kmeans.ssi.png" alt="19"><br>
k-均值聚类结果空间分布图</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plot(spa, <span class="attribute">asp</span>=1, <span class="attribute">type</span>=<span class="string">"n"</span>, <span class="attribute">main</span>=<span class="string">"Four k-means groups"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"x coordinate (km)"</span>, <span class="attribute">ylab</span>=<span class="string">"y coordinate (km)"</span>)</span><br><span class="line">lines(spa, <span class="attribute">col</span>=<span class="string">"light blue"</span>)</span><br><span class="line">text(50, 10, <span class="string">"Upstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line">text(25, 115, <span class="string">"Downstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line">grKM &lt;- spe.kmeans<span class="variable">$cluster</span></span><br><span class="line">k &lt;- length(levels(factor(grKM)))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1:k) &#123;</span><br><span class="line">   points(spa[<span class="attribute">grKM</span>==i,1], spa[<span class="attribute">grKM</span>==i,2], <span class="attribute">pch</span>=i+20, <span class="attribute">cex</span>=2, <span class="attribute">col</span>=i+1, <span class="attribute">bg</span>=i+1)</span><br><span class="line">   &#125;</span><br><span class="line">text(spa, row.names(spa), <span class="attribute">cex</span>=0.8, <span class="attribute">col</span>=<span class="string">"white"</span>, <span class="attribute">font</span>=2)</span><br><span class="line">legend(<span class="string">"bottomright"</span>, paste(<span class="string">"Group"</span>,1:k), pch=(1:k)+20, <span class="attribute">col</span>=2:(k+1),</span><br><span class="line">  pt.<span class="attribute">bg</span>=2:(k+1), pt.<span class="attribute">cex</span>=2, <span class="attribute">bty</span>=<span class="string">"n"</span>)</span><br></pre></td></tr></table></figure>
<p>22.spatial.kmeans<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/22.spatial.kmeans.png" alt="22"></p>
<h2 id="围绕中心点划分（PAM）">围绕中心点划分（PAM）</h2>
<ul>
<li>k-均值法师传统的最小二乘法，但PAM不是。pam的优势是可以输入原始数据和相异矩阵，并且允许通过轮廓宽度值确定最佳的分组数量。</li>
</ul>
<p>示例：利用轮廓图比较k-均值法和PAM法的分组结果<br>
基于弦距离矩阵进行计算</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asw &lt;- numeric(nrow(spe))</span><br><span class="line"><span class="comment">#循环计算2到28组分类数下平均轮廓宽度（asw）</span></span><br><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> 2:(nrow(spe)-1))</span><br><span class="line">	asw[k] &lt;- pam(spe.ch, k, <span class="attribute">diss</span>=<span class="literal">TRUE</span>)$silinfo$avg.width #<span class="attribute">diss</span>=<span class="literal">TRUE</span>表示是相异矩阵</span><br><span class="line">k.best &lt;- which.max(asw)</span><br><span class="line">cat(<span class="string">""</span>, <span class="string">"Silhouette-optimal number of clusters k ="</span>, k.best, <span class="string">"\n"</span>,</span><br><span class="line">	<span class="string">"with an average silhouette width of"</span>, max(asw), <span class="string">"\n"</span>)</span><br><span class="line">plot(1:nrow(spe), asw, <span class="attribute">type</span>=<span class="string">"h"</span>, <span class="attribute">main</span>=<span class="string">"Choice of the number of clusters"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"k (number of groups)"</span>, <span class="attribute">ylab</span>=<span class="string">"Average silhouette width"</span>)</span><br><span class="line">axis(1, k.best, paste(<span class="string">"optimum"</span>,k.best,<span class="attribute">sep</span>=<span class="string">"\n"</span>), <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">font</span>=2,</span><br><span class="line">	col.<span class="attribute">axis</span>=<span class="string">"red"</span>)</span><br><span class="line">points(k.best, max(asw), <span class="attribute">pch</span>=16, <span class="attribute">col</span>=<span class="string">"red"</span>, <span class="attribute">cex</span>=1.5)</span><br></pre></td></tr></table></figure>
<p>20.pam<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/20.pam.png" alt="20"><br>
可见k=2时，PAM具有最佳方案。尽管如此，下面我们还是使用k=4进行演示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.pam</span> &lt;- pam(spe<span class="selector-class">.ch</span>, k=<span class="number">4</span>, diss=TRUE)</span><br><span class="line"><span class="function"><span class="title">summary</span><span class="params">(spe.ch.pam)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.pam</span><span class="selector-class">.g</span> &lt;- spe<span class="selector-class">.ch</span>.pam<span class="variable">$clustering</span>#裁剪的分组</span><br><span class="line">spe<span class="selector-class">.ch</span>.pam<span class="variable">$silinfo</span><span class="variable">$widths</span>#asw值</span><br><span class="line">#将当前的结果与之前的ward聚类和k-均值划分进行比较</span><br><span class="line"><span class="function"><span class="title">table</span><span class="params">(spe.ch.pam.g, spebc.ward.g)</span></span></span><br><span class="line"><span class="function"><span class="title">table</span><span class="params">(spe.ch.pam.g, spe.kmeans<span class="variable">$cluster</span>)</span></span></span><br><span class="line">#绘制k-均值法和PAM法的轮廓宽度图</span><br><span class="line"><span class="function"><span class="title">par</span><span class="params">(mfrow=c(<span class="number">1</span>,<span class="number">2</span>)</span></span>)</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(silhouette(spe.kmeans<span class="variable">$cluster</span>,spe.ch)</span></span>, main=<span class="string">"Silhouette plot - k-means"</span>,</span><br><span class="line">  cex.names=<span class="number">0.8</span>, col= spe.kmeans<span class="variable">$cluster</span>+<span class="number">1</span>,<span class="attribute">border</span>=<span class="string">"white"</span>)</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(silhouette(spe.ch.pam)</span></span>, main=<span class="string">"Silhouette plot - PAM"</span>, cex.names=<span class="number">0.8</span>,</span><br><span class="line">	col=spe<span class="selector-class">.ch</span>.pam<span class="variable">$silinfo</span><span class="variable">$widths</span>+<span class="number">1</span>,<span class="attribute">border</span>=<span class="string">"white"</span>)#哪个更好？</span><br></pre></td></tr></table></figure>
<p>21.kmeanspam<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/21.kmeanspam.png" alt="21"><br>
可见，即使是目标相同且属于同一大类的两种方法，结果也可能完全不同。用户应该根据哪种方法的结果能够提供更多有用的信息，或能更好地被环境变量解释来选择合适的方法。</p>
<h1>用环境数据进行比较</h1>
<p>上述均是基于物种多度数据进行的演示，也可以用于其他类型的数据，特别是环境数据。</p>
<h2 id="用外部数据进行类型比较（方差分析途径）">用外部数据进行类型比较（方差分析途径）</h2>
<ul>
<li>作为响应数据，可以用 <strong>判别式分析</strong>；</li>
<li>作为解释变量（因子），可以进行 <strong>方差分析</strong>，了解解释变量在各组间是否有显著差异。</li>
</ul>
<p>示例：基于k-均值划分结果（分4组）的样方聚类簇与4个环境变量的关系</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">attach(env) #避免对象名称的重复输入</span><br><span class="line">par(<span class="attribute">mfrow</span>=c(2,2))</span><br><span class="line"><span class="comment">#定量环境变量箱线图</span></span><br><span class="line">boxplot(sqrt(alt) ~ spe.kmeans<span class="variable">$cluster</span>, <span class="attribute">main</span>=<span class="string">"Alititude"</span>, <span class="attribute">las</span>=1,</span><br><span class="line">  <span class="attribute">ylab</span>=<span class="string">"sqrt(alt)"</span>, <span class="attribute">col</span>=2:5, <span class="attribute">varwidth</span>=<span class="literal">TRUE</span>)</span><br><span class="line">boxplot(log(pen) ~ spe.kmeans<span class="variable">$cluster</span>, <span class="attribute">main</span>=<span class="string">"Pen"</span>, <span class="attribute">las</span>=1,</span><br><span class="line">  <span class="attribute">ylab</span>=<span class="string">"log(pen)"</span>, <span class="attribute">col</span>=2:5, <span class="attribute">varwidth</span>=<span class="literal">TRUE</span>)</span><br><span class="line">boxplot(oxy ~ spe.kmeans<span class="variable">$cluster</span>, <span class="attribute">main</span>=<span class="string">"Oxygen"</span>, <span class="attribute">las</span>=1,</span><br><span class="line">  <span class="attribute">ylab</span>=<span class="string">"oxy"</span>, <span class="attribute">col</span>=2:5, <span class="attribute">varwidth</span>=<span class="literal">TRUE</span>)</span><br><span class="line">boxplot(sqrt(amm) ~ spe.kmeans<span class="variable">$cluster</span>, <span class="attribute">main</span>=<span class="string">"Ammonium"</span>, <span class="attribute">las</span>=1,</span><br><span class="line">  <span class="attribute">ylab</span>=<span class="string">"sqrt(amm)"</span>, <span class="attribute">col</span>=2:5, <span class="attribute">varwidth</span>=<span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#检验方差分析的假设</span></span><br><span class="line"><span class="comment">##检验残差的正态性(P&gt;0.05则满足正态分布)</span></span><br><span class="line">shapiro.test(resid(lm(sqrt(alt) ~ as.factor(spe.kmeans<span class="variable">$cluster</span>))))</span><br><span class="line">shapiro.test(resid(lm(log(pen) ~ as.factor(spe.kmeans<span class="variable">$cluster</span>))))</span><br><span class="line">shapiro.test(resid(lm(oxy ~ as.factor(spe.kmeans<span class="variable">$cluster</span>))))</span><br><span class="line">shapiro.test(resid(lm(sqrt(amm) ~ as.factor(spe.kmeans<span class="variable">$cluster</span>))))</span><br><span class="line"><span class="comment">##检验方差齐性(P&gt;0.05则满足方差齐性)</span></span><br><span class="line">bartlett.test(sqrt(alt), as.factor(spe.kmeans<span class="variable">$cluster</span>))#不满足</span><br><span class="line">bartlett.test(log(pen), as.factor(spe.kmeans<span class="variable">$cluster</span>))</span><br><span class="line">bartlett.test(oxy, as.factor(spe.kmeans<span class="variable">$cluster</span>))</span><br><span class="line">bartlett.test(sqrt(amm), as.factor(spe.kmeans<span class="variable">$cluster</span>))</span><br><span class="line"><span class="comment">#显著性检验：aov比较多组（参数）；kruskal.test比较多组（非参数）。</span></span><br><span class="line">kruskal.test(alt ~ as.factor(spe.kmeans<span class="variable">$cluster</span>))#P&lt;0.05则差异显著，下同。</span><br><span class="line">summary(aov(log(pen) ~ as.factor(spe.kmeans<span class="variable">$cluster</span>)))</span><br><span class="line">summary(aov(oxy ~ as.factor(spe.kmeans<span class="variable">$cluster</span>)))</span><br><span class="line">summary(aov(sqrt(amm) ~ as.factor(spe.kmeans<span class="variable">$cluster</span>)))</span><br><span class="line">detach(env)</span><br></pre></td></tr></table></figure>
<p>23.envboxplot<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/23.envboxplot.png" alt="23"></p>
<h2 id="双类型比较（列联表分析）">双类型比较（列联表分析）</h2>
<ul>
<li>直接比较分别基于物种数据和环境数据的聚类结果</li>
</ul>
<p>示例</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">env2 &lt;- env[,-1]</span><br><span class="line">env.<span class="keyword">de</span> &lt;- vegdist(scale(env2), <span class="string">"euc"</span>)</span><br><span class="line">env.kmeans &lt;- kmeans(env.<span class="keyword">de</span>, centers=4, nstart=100)</span><br><span class="line">env.KM.4 &lt;- env.kmeans<span class="variable">$cluster</span></span><br><span class="line">#比较两种聚类的结果</span><br><span class="line"><span class="keyword">table</span>(<span class="keyword">as</span>.<span class="keyword">factor</span>(spe.kmeans<span class="variable">$cluster</span>), <span class="keyword">as</span>.<span class="keyword">factor</span>(env.kmeans<span class="variable">$cluster</span>))</span><br><span class="line">#用卡方检验分析两种聚类之间的差异</span><br><span class="line">chisq.<span class="keyword">test</span>(<span class="keyword">as</span>.<span class="keyword">factor</span>(spe.kmeans<span class="variable">$cluster</span>), <span class="keyword">as</span>.<span class="keyword">factor</span>(env.kmeans<span class="variable">$cluster</span>))</span><br><span class="line">#改用置换的方法(蒙特卡洛检验）进行卡方检验分析</span><br><span class="line">chisq.<span class="keyword">test</span>(<span class="keyword">as</span>.<span class="keyword">factor</span>(spe.kmeans<span class="variable">$cluster</span>), <span class="keyword">as</span>.<span class="keyword">factor</span>(env.kmeans<span class="variable">$cluster</span>),</span><br><span class="line">	<span class="keyword">simulate</span>.p.value=TRUE)#<span class="keyword">simulate</span>.p.value, a logical indicating whether to compute p-values <span class="keyword">by</span> Monte Carlo simulation.</span><br></pre></td></tr></table></figure>
<h1>物种集合</h1>
<p>识别数据集内的物种关联</p>
<h2 id="组内数据简单统计：平均多度">组内数据简单统计：平均多度</h2>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#k-均值样方聚类平均多度</span><br><span class="line">groups &lt;- <span class="keyword">as</span>.<span class="keyword">factor</span>(spe.kmeans<span class="variable">$cluster</span>)</span><br><span class="line">spe.<span class="keyword">means</span> &lt;- <span class="built_in">matrix</span>(0, ncol(spe), <span class="built_in">length</span>(<span class="keyword">levels</span>(groups)))#<span class="built_in">matrix</span>(data,nrow,ncol,...)</span><br><span class="line">row.names(spe.<span class="keyword">means</span>) &lt;- colnames(spe)</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> 1:ncol(spe)) &#123;</span><br><span class="line">  spe.<span class="keyword">means</span>[i,] &lt;- tapply(spe[,i], spe.kmeans<span class="variable">$cluster</span>, <span class="keyword">mean</span>)</span><br><span class="line">  &#125;</span><br><span class="line">#每组的物种平均多度</span><br><span class="line">group1 &lt;- <span class="built_in">round</span>(<span class="keyword">sort</span>(spe.<span class="keyword">means</span>[,1], decreasing=TRUE), 2)</span><br><span class="line">group2 &lt;- <span class="built_in">round</span>(<span class="keyword">sort</span>(spe.<span class="keyword">means</span>[,2], decreasing=TRUE), 2)</span><br><span class="line">group3 &lt;- <span class="built_in">round</span>(<span class="keyword">sort</span>(spe.<span class="keyword">means</span>[,3], decreasing=TRUE), 2)</span><br><span class="line">group4 &lt;- <span class="built_in">round</span>(<span class="keyword">sort</span>(spe.<span class="keyword">means</span>[,4], decreasing=TRUE), 2)</span><br><span class="line">#显示多度大于平均值的物种</span><br><span class="line">group1.domin &lt;- <span class="keyword">which</span>(group1&gt;<span class="keyword">mean</span>(group1))</span><br><span class="line">group1.domin #...对其他组进行相同的分析</span><br></pre></td></tr></table></figure>
<h2 id="Kendall共性系数（W）">Kendall共性系数（W）</h2>
<p>不适用于物种有-无数据<br>
“当判断的数量[=物种数]很少时，Kendall共性检验最适合。”<br>
示例</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#提取多度最大的物种（选择前<span class="number">20</span>种）</span><br><span class="line"><span class="keyword">sp</span>.sum &lt;- apply(<span class="keyword">spe</span>, <span class="number">2</span>, sum)</span><br><span class="line"><span class="keyword">spe</span>.sorted &lt;- <span class="keyword">spe</span>[,order(<span class="keyword">sp</span>.sum, decreasing=TRUE)]</span><br><span class="line"><span class="keyword">spe</span>.small &lt;- <span class="keyword">spe</span>.sorted[,<span class="number">1</span>:<span class="number">20</span>]</span><br><span class="line">#物种数据转化和矩阵转置</span><br><span class="line"><span class="keyword">spe</span>.small.hel &lt;- decostand(<span class="keyword">spe</span>.small, <span class="string">"hellinger"</span>)</span><br><span class="line"><span class="keyword">spe</span>.small.std &lt;- decostand(<span class="keyword">spe</span>.small.hel, <span class="string">"standardize"</span>)</span><br><span class="line"><span class="keyword">spe</span>.small.t &lt;- t(<span class="keyword">spe</span>.small.std)</span><br><span class="line">#物种<span class="keyword">k</span>-均值划分</span><br><span class="line"><span class="keyword">spe</span>.t.kmeans.casc &lt;- cascadeKM(<span class="keyword">spe</span>.small.t, inf.<span class="keyword">gr</span>=<span class="number">2</span>, sup.<span class="keyword">gr</span>=<span class="number">8</span>,</span><br><span class="line">	iter=<span class="number">100</span>, criterion=<span class="string">"calinski"</span>)</span><br><span class="line">plot(<span class="keyword">spe</span>.t.kmeans.casc, sortg=TRUE)#结果显示划分为<span class="number">2</span>组最合适</span><br><span class="line">#选择<span class="number">2</span>组的划分</span><br><span class="line">clusters &lt;- <span class="keyword">spe</span>.t.kmeans.casc$partition[,<span class="number">1</span>]</span><br><span class="line">clusters</span><br><span class="line">#对这两组进行全局的Kendall W检验，识别所有物种组是否显著关联</span><br><span class="line"><span class="keyword">spe</span>.kendall.<span class="keyword">global</span> &lt;- kendall.<span class="keyword">global</span>(<span class="keyword">spe</span>.small.hel, clusters)</span><br><span class="line"><span class="keyword">spe</span>.kendall.global#w，kendall共性系数；corrected prob.perm，显著性</span><br><span class="line">#若显著关联，则对每个组物种进行后验概率检验，验证同一组内的物种是否具有共性。</span><br><span class="line"><span class="keyword">spe</span>.kendall.post &lt;- kendall.post(<span class="keyword">spe</span>.small.hel, clusters, nperm=<span class="number">9999</span>)</span><br><span class="line"><span class="keyword">spe</span>.kendall.post#p&gt;<span class="number">0.05</span>，要排除；spearman.mean，负值要排除，如果负值较多，表明当前的分组可能需要细分。</span><br></pre></td></tr></table></figure>
<p>24.kmeansclusters<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/24.kmeansclusters.png" alt="24"></p>
<h2 id="基于有-无数据的物种集合">基于有-无数据的物种集合</h2>
<p>计算R-模式Jaccard系数的a组分（物种间共发生的测度）并通过Raup和Crick系数置换检验评估a的概率。此时p值可以当作距离：共发生度越高的两个物种，其p值越小。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#使用自编的test.a()计算</span><br><span class="line"><span class="function"><span class="title">source</span><span class="params">(<span class="string">"test.a.R"</span>)</span></span>                </span><br><span class="line">spe<span class="selector-class">.pa</span> &lt;- decostand(spe,<span class="string">"pa"</span>)#将物种数据转化为有-无数据</span><br><span class="line">res &lt;- test.a(spe<span class="selector-class">.pa</span>, nperm=<span class="number">99999</span>)#设定置换检验中足够的置换次数以获得多重检验的显著水平。</span><br><span class="line"><span class="function"><span class="title">summary</span><span class="params">(res)</span></span>#输出的结果是res<span class="variable">$p</span><span class="selector-class">.a</span>.dist包含一个p值的矩阵。下一步计算向量化的p值矩阵的Holm校正数。</span><br><span class="line">res<span class="selector-class">.p</span><span class="selector-class">.vec</span> &lt;- as.vector(res<span class="variable">$p</span><span class="selector-class">.a</span>.dist)</span><br><span class="line">adjust<span class="selector-class">.res</span> &lt;- <span class="selector-tag">p</span>.adjust(res<span class="selector-class">.p</span><span class="selector-class">.vec</span>,method=<span class="string">"holm"</span>)</span><br><span class="line">#不明白怎么出来的<span class="number">0.00018</span>？？？？</span><br><span class="line">res<span class="selector-class">.pa</span><span class="selector-class">.dist</span> &lt;- res<span class="variable">$p</span><span class="selector-class">.a</span>.dist</span><br><span class="line">res<span class="selector-class">.pa</span><span class="selector-class">.dist</span>[res<span class="selector-class">.pa</span>.dist&gt;<span class="number">0.00018</span>] &lt;- <span class="number">1</span></span><br><span class="line">#由p值构成的相异矩阵可以用热图表示</span><br><span class="line"><span class="function"><span class="title">source</span><span class="params">(<span class="string">"coldiss.R"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">coldiss</span><span class="params">(res.pa.dist, nc=<span class="number">10</span>, byrank=TRUE, diag=TRUE)</span></span></span><br><span class="line">#运行模糊非层次聚类(fanny())，尝试使用多k值获得最佳的分组</span><br><span class="line">res<span class="selector-class">.pa</span><span class="selector-class">.fuz</span> &lt;- fanny(res<span class="selector-class">.pa</span><span class="selector-class">.dist</span>, k=<span class="number">5</span>, memb.exp=<span class="number">1.5</span>)</span><br><span class="line"><span class="function"><span class="title">summary</span><span class="params">(res.pa.fuz)</span></span></span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(silhouette(res.pa.fuz)</span></span>, main=<span class="string">"Silhouette plot - Fuzzy clustering"</span>, cex.names=<span class="number">0.8</span>, col=res<span class="selector-class">.pa</span>.fuz<span class="variable">$silinfo</span><span class="variable">$widths</span>+<span class="number">1</span>)</span><br><span class="line">res<span class="selector-class">.pa</span>.fuz<span class="variable">$silinfo</span> #轮廓信息，包含一个聚类簇中最可能的成员(<span class="string">"cluster"</span>)、最近邻体聚类簇(<span class="string">"neighbor"</span>)和轮廓宽度值(<span class="string">"sil_width"</span>).</span><br></pre></td></tr></table></figure>
<h2 id="IndVal：物种指示值">IndVal：物种指示值</h2>
<p>先基于非物种数据（例如环境数据）对样方进行聚类，然后再找指示物种。此时，指示物种才是真正具有指示意义的指示种，即该物种与该样方组所在的生态环境关系最为密切。<br>
指示值的后验统计显著性（即观察值和随机值的比较）可以通过置换检验进行评估。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#依据das（离源头距离）环境变量将样方分为4组</span></span><br><span class="line">das.D1 &lt;- dist(data.frame(<span class="attribute">das</span>=env[,1], row.<span class="attribute">names</span>=rownames(env)))</span><br><span class="line">dasD1.kmeans &lt;- kmeans(das.D1, <span class="attribute">centers</span>=4, <span class="attribute">nstart</span>=100)</span><br><span class="line">dasD1.kmeans<span class="variable">$cluster</span></span><br><span class="line"><span class="comment">#样方组的指示种</span></span><br><span class="line">(iva &lt;- indval(spe, dasD1.kmeans<span class="variable">$cluster</span>) )#relfrq：物种在每个组的相对频度；relabu：物种在组间的相对多度；indval：每个物种的指示值</span><br><span class="line"><span class="comment">#下面两项内容将从indval表格内提取出来（含有最高指示值的组）和置换检验的结果。</span></span><br><span class="line"><span class="comment">#显著指示物种的表格</span></span><br><span class="line">gr &lt;- iva<span class="variable">$maxcls</span>[iva<span class="variable">$pval</span>&lt;=0.05]#maxcls表示具有最大指示值的分类</span><br><span class="line">iv &lt;- iva<span class="variable">$indcls</span>[iva<span class="variable">$pval</span>&lt;=0.05]#indcls表示每个物种在最大分类中的指示值</span><br><span class="line">pv &lt;- iva<span class="variable">$pval</span>[iva<span class="variable">$pval</span>&lt;=0.05]#pval表示获得观察到的指定迭代中高指示值的可能性</span><br><span class="line">fr &lt;- apply(spe&gt;0, 2, sum)[iva<span class="variable">$pval</span>&lt;=0.05]#计算每个物种出现的频数</span><br><span class="line">fidg &lt;- data.frame(<span class="attribute">group</span>=gr, <span class="attribute">indval</span>=iv, <span class="attribute">pvalue</span>=pv, <span class="attribute">freq</span>=fr)</span><br><span class="line">fidg &lt;- fidg[order(fidg<span class="variable">$group</span>, -fidg<span class="variable">$indval</span>),]#fidg<span class="variable">$group</span>升序，fidg<span class="variable">$indval</span>降序。</span><br><span class="line">fidg</span><br><span class="line"><span class="comment">#将结果输出为csv文件</span></span><br><span class="line">write.csv(fidg, <span class="string">"IndVal-das.csv"</span>)</span><br></pre></td></tr></table></figure>
<h1>多元回归树：约束聚类</h1>
<h2 id="引言-2">引言</h2>
<p>多元回归树（multivariate regression tree, MRT）目的：在定量或分类解释变量的控制下递归划分一个定量变量。<br>
在约束排序中，选择解释变量的依据是依照解释能力的大小，而MRT选择解释变量是侧重预测能力的大小。</p>
<h2 id="计算（原理）">计算（原理）</h2>
<p>MRT的计算由两个一起运行的程序组成：①数据约束划分；②分组结果交叉验证。</p>
<h3 id="数据约束划分">数据约束划分</h3>
<p>1.对于每一个解释变量，将样方分为所有可能的两组情况：①对于一个定量解释变量，按照变量值大小先对样方进行排列，然后在第1个、第2个…第n-1个间隔点将样方划分为n-1种可能的两组分组情况；②对于分类变量，将变量所有水平随机组合成所有可能的两组，在每种情况下，样方也跟随变量水平的组合分为两组。两种情况，选择 <strong>最小距离平方和的分组情况</strong>，并确认此分组情况所对应的解释变量的分割点或分类变量的水平组合。<br>
2.继续按照上述方法划分亚组。<br>
3.直到每个对象成为独立的一组位置。我们一般需要的是 <strong>大小（组数）合适的树</strong>。如何确定大小合适的树，<strong>交叉验证</strong>。<br>
4.<strong>相对误差（RE）</strong> 是回归树不能解释的方差比例。如果没有 <strong>交叉验证</strong>，我们应该保留 <strong>最小RE</strong> 的回归树，即 <strong>保留最高R<SUP>2</SUP>的回归树</strong>。然而R<SUP>2</SUP>最高的回归树解释能力最好，不代表预测能力最好。</p>
<h3 id="交叉验证和回归树的裁剪">交叉验证和回归树的裁剪</h3>
<p>如何对回归树进行裁剪（即保留最佳分类方案）？从预测的角度，可以利用原始数据的一部分构建一棵树，剩下另一部分验证训练组构建的树的准确性。<br>
<strong>预测误差的测度称为CVRE。CVRE为0是最完美的预测，接近1是最差的预测。</strong></p>
<h2 id="使用mvpart和MVPARTwrap程序包运行MRT">使用mvpart和MVPARTwrap程序包运行MRT</h2>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">library(mvpart)</span><br><span class="line">spe.ch.mvpart &lt;- mvpart(data.matrix(spe.norm) ~ ., env, <span class="attribute">margin</span>=0.08, <span class="attribute">cp</span>=0,</span><br><span class="line">	<span class="attribute">xv</span>=<span class="string">"pick"</span>, <span class="attribute">xval</span>=nrow(spe), <span class="attribute">xvmult</span>=100, <span class="attribute">which</span>=4)#人机交互；交叉验证分组为29,迭代次数100，分为4组。</span><br><span class="line">summary(spe.ch.mvpart)</span><br><span class="line">printcp(spe.ch.mvpart)</span><br><span class="line"><span class="comment">#橘红色的水平线指示最小CVRE（大红点）的1个标准差范围。</span></span><br><span class="line"><span class="comment">#可以①选择在1个最小CRVE的标准误差范围内分组最少的分类树，即橙色点；</span></span><br><span class="line"><span class="comment">#或②选择最小CRVE，即红色点。</span></span><br><span class="line"><span class="comment">#从图中可见，两者相差不大。</span></span><br></pre></td></tr></table></figure>
<p>25.CVRE<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/25.CVRE.jpg" alt="25"><br>
交互模式下，在想要的分组组数的地方惦记鼠标左键，会生成一个回归树。最下面显示的是物种多度分布条形图、RE和所含样方数目。<br>
26.MRT<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/26.MRT.png" alt="26"><br>
下面的代码可以查看残差，并检索每个节点的不同对象并查看每个节点的特征：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">par</span><span class="params">(mfrow=c(<span class="number">1</span>,<span class="number">2</span>)</span></span>)</span><br><span class="line"><span class="function"><span class="title">hist</span><span class="params">(residuals(spe.ch.mvpart)</span></span>, col=<span class="string">"grey"</span>) #残差</span><br><span class="line"><span class="function"><span class="title">plot</span><span class="params">(predict(spe.ch.mvpart)</span></span>, apply(residuals(spe<span class="selector-class">.ch</span>.mvpart),<span class="number">1</span>,mean),</span><br><span class="line">	main=<span class="string">"Residuals vs Predicted"</span>)</span><br><span class="line"><span class="function"><span class="title">abline</span><span class="params">(h=<span class="number">0</span>, lty=<span class="number">3</span>, col=<span class="string">"grey"</span>)</span></span></span><br><span class="line">spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>#组的名称</span><br><span class="line">(groups<span class="selector-class">.mrt</span> &lt;- levels(as.factor(spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>)))#识别组的名称</span><br><span class="line">spe<span class="selector-class">.norm</span>[which(spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>==groups<span class="selector-class">.mrt</span>[<span class="number">1</span>]),]#第一片叶子的物种鱼类组成</span><br><span class="line">env[which(spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>==groups<span class="selector-class">.mrt</span>[<span class="number">1</span>]),]#第一片叶子的环境变量组成</span><br><span class="line">#叶子的鱼类物种组成表格和饼图</span><br><span class="line">leaf<span class="selector-class">.sum</span> &lt;- matrix(<span class="number">0</span>, length(groups.mrt), ncol(spe))</span><br><span class="line"><span class="function"><span class="title">colnames</span><span class="params">(leaf.sum)</span></span> &lt;- colnames(spe)</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(i in <span class="number">1</span>:length(groups.mrt)</span></span>)&#123;</span><br><span class="line">  leaf<span class="selector-class">.sum</span>[<span class="selector-tag">i</span>,] &lt;- apply(spe<span class="selector-class">.norm</span>[which(spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>==groups<span class="selector-class">.mrt</span>[i]),],</span><br><span class="line">    <span class="number">2</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line">leaf.sum</span><br><span class="line"><span class="function"><span class="title">par</span><span class="params">(mfrow=c(<span class="number">2</span>,<span class="number">2</span>)</span></span>)</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(i in <span class="number">1</span>:length(groups.mrt)</span></span>)&#123;</span><br><span class="line">	pie(which(leaf<span class="selector-class">.sum</span>[<span class="selector-tag">i</span>,]&gt;<span class="number">0</span>), radius=<span class="number">1</span>, main=c(<span class="string">"leaf #"</span>, groups<span class="selector-class">.mrt</span>[i]))</span><br><span class="line">&#125;</span><br><span class="line">#从mvpart()函数获得的结果对象无法提取更多的数量信息，所以开发了附加程序包：MVPARTwrap。</span><br><span class="line">##从mvpart()函数获得的结果对象中提取MRT结果</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.mvpart</span><span class="selector-class">.wrap</span> &lt;- MRT(spe<span class="selector-class">.ch</span><span class="selector-class">.mvpart</span>, percent=<span class="number">10</span>, species=colnames(spe))</span><br><span class="line"><span class="function"><span class="title">summary</span><span class="params">(spe.ch.mvpart.wrap)</span></span> #可查看判别物种（Discriminant species）。</span><br></pre></td></tr></table></figure>
<h2 id="组合MRT和IndVal">组合MRT和IndVal</h2>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#在MRT的结果中寻找指示种</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span><span class="selector-class">.indval</span> &lt;- indval(spe<span class="selector-class">.norm</span>, spe<span class="selector-class">.ch</span>.mvpart<span class="variable">$where</span>)</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span>.indval<span class="variable">$pval</span> #概率</span><br><span class="line">#为每个显著的物种寻找最高指示值的叶子</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span>.indval<span class="variable">$maxcls</span>[which(spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span>.indval<span class="variable">$pval</span>&lt;=<span class="number">0.05</span>)]</span><br><span class="line">#每个显著的物种在最高指示值的叶子中的指示值</span><br><span class="line">spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span>.indval<span class="variable">$indcls</span>[which(spe<span class="selector-class">.ch</span><span class="selector-class">.MRT</span>.indval<span class="variable">$pval</span>&lt;=<span class="number">0.05</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="作为时序性（chronological）聚类方法的MRT">作为时序性（chronological）聚类方法的MRT</h2>
<p>在某些情况下，数据本身具有空间和时间系列属性，此时对数据进行分组时需要考虑数据之间的连续性。<br>
利用MRT解决时间和空间序列问题很简单：将空间变量（或时间变量）作为唯一的解释变量进行MRT分析。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MRT作为空间和时间系列约束聚类方法</span></span><br><span class="line">spe.ch.seq &lt;- mvpart(as.matrix(spe) ~ das, env, <span class="attribute">cp</span>=0, <span class="attribute">xv</span>=<span class="string">"pick"</span>, <span class="attribute">margin</span>=0.08,</span><br><span class="line">  <span class="attribute">xval</span>=nrow(spe), <span class="attribute">xvmult</span>=100, <span class="attribute">which</span>=4)</span><br><span class="line"><span class="comment">#此时可以点击所期望的分组组数</span></span><br><span class="line">summary(spe.ch.seq)</span><br><span class="line"><span class="comment">#组的组成（终端节点的标识）</span></span><br><span class="line">(gr &lt;- spe.ch.seq<span class="variable">$where</span>)</span><br><span class="line"><span class="comment">#重新编排聚类簇的编号</span></span><br><span class="line">aa &lt;- 1</span><br><span class="line">gr2 &lt;- rep(1,length(gr))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 2:length(gr)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (gr[i]!=gr[i-1]) aa &lt;- aa+1</span><br><span class="line">  gr2[i] &lt;- aa</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在Doubs河地图上标注样方所属的聚类簇</span></span><br><span class="line">plot(spa, <span class="attribute">asp</span>=1, <span class="attribute">type</span>=<span class="string">"n"</span>, <span class="attribute">main</span>=<span class="string">"MRT groups"</span>,</span><br><span class="line">	<span class="attribute">xlab</span>=<span class="string">"x coordinate (km)"</span>, <span class="attribute">ylab</span>=<span class="string">"y coordinate (km)"</span>)</span><br><span class="line">lines(spa, <span class="attribute">col</span>=<span class="string">"light blue"</span>)</span><br><span class="line">text(40, 15, <span class="string">"Upstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line">text(15, 115, <span class="string">"Downstream"</span>, <span class="attribute">cex</span>=1.2, <span class="attribute">col</span>=<span class="string">"red"</span>)</span><br><span class="line">k &lt;- length(levels(factor(gr2)))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1:k) &#123;</span><br><span class="line">   points(spa[<span class="attribute">gr2</span>==i,1], spa[<span class="attribute">gr2</span>==i,2], <span class="attribute">pch</span>=i+20, <span class="attribute">cex</span>=2, <span class="attribute">col</span>=i+1, <span class="attribute">bg</span>=i+1)</span><br><span class="line">   &#125;</span><br><span class="line">text(spa, row.names(spa), <span class="attribute">cex</span>=0.6, <span class="attribute">col</span>=<span class="string">"white"</span>, <span class="attribute">font</span>=2)</span><br><span class="line">legend(<span class="string">"bottomright"</span>, paste(<span class="string">"Group"</span>,1:k), pch=(1:k)+20, <span class="attribute">col</span>=2:(k+1),</span><br><span class="line">  pt.<span class="attribute">bg</span>=2:(k+1), pt.<span class="attribute">cex</span>=2, <span class="attribute">bty</span>=<span class="string">"n"</span>)</span><br></pre></td></tr></table></figure>
<p>27.spatial.mrt<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/27.spatial.mrt.png" alt="27"></p>
<h1>另类途径：模糊聚类</h1>
<p>模糊聚类，聚类簇的界限并不明显。<br>
下面简单介绍一下c-均值聚类：</p>
<h2 id="使用cluster程序包内fanny-函数进行c-均值模糊聚类">使用cluster程序包内fanny()函数进行c-均值模糊聚类</h2>
<p>一个对象可以赋予不同的组，对象与组之间的归属程度可以通过成员值（membership value）衡量。一个对象在某一组内的成员值越高，表示该对象与该组之间的关系越紧密，反之亦然。每个对象的成员值总和为1.</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#鱼类数据的c-均值模糊聚类</span></span><br><span class="line">k &lt;- 4  #选择聚类分组的数量</span><br><span class="line">spe.fuz &lt;- fanny(spe.ch, <span class="attribute">k</span>=k, memb.<span class="attribute">exp</span>=1.5)</span><br><span class="line">summary(spe.fuz)</span><br><span class="line">spefuz.g &lt;- spe.fuz<span class="variable">$clustering</span></span><br><span class="line"><span class="comment">#样方成员值</span></span><br><span class="line">spe.fuz<span class="variable">$membership</span></span><br><span class="line"><span class="comment">#每个样方最接近的聚类簇</span></span><br><span class="line">spe.fuz<span class="variable">$clustering</span></span><br><span class="line"><span class="comment">#轮廓图</span></span><br><span class="line">plot(silhouette(spe.fuz), <span class="attribute">main</span>=<span class="string">"Silhouette plot - Fuzzy clustering"</span>,</span><br><span class="line">  cex.<span class="attribute">names</span>=0.8, <span class="attribute">col</span>=spe.fuz$silinfo$widths+1,border="white")</span><br></pre></td></tr></table></figure>
<p>28.fuzzy.silhouette<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/28.fuzzy.silhouette.png" alt="28"></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模糊聚类簇的主坐标排序（PCoA）</span></span><br><span class="line">dc.pcoa &lt;- cmdscale(spe.ch)</span><br><span class="line">dc.scores &lt;- scores(dc.pcoa, <span class="attribute">choices</span>=c(1,2))</span><br><span class="line">plot(scores(dc.pcoa), <span class="attribute">asp</span>=1, <span class="attribute">type</span>=<span class="string">"n"</span>,</span><br><span class="line">	<span class="attribute">main</span>=<span class="string">"Ordination of fuzzy clusters (PCoA)"</span>)</span><br><span class="line">abline(<span class="attribute">h</span>=0, <span class="attribute">lty</span>=<span class="string">"dotted"</span>)</span><br><span class="line">abline(<span class="attribute">v</span>=0, <span class="attribute">lty</span>=<span class="string">"dotted"</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> 1:k) &#123;</span><br><span class="line">	gg &lt;- dc.scores[spefuz.<span class="attribute">g</span>==i,]</span><br><span class="line">	hpts &lt;- chull(gg)  </span><br><span class="line">	hpts &lt;- c(hpts, hpts[1])</span><br><span class="line">	lines(gg[hpts,], <span class="attribute">col</span>=i+1)</span><br><span class="line">	&#125;</span><br><span class="line">stars(spe.fuz<span class="variable">$membership</span>, <span class="attribute">location</span>=scores(dc.pcoa), draw.<span class="attribute">segments</span>=<span class="literal">TRUE</span>,</span><br><span class="line">	<span class="attribute">add</span>=<span class="literal">TRUE</span>, <span class="attribute">scale</span>=<span class="literal">FALSE</span>, <span class="attribute">len</span>=0.1, col.<span class="attribute">segments</span>=2:(k+1))</span><br><span class="line">legend(locator(1), paste(<span class="string">"Cluster"</span>, 1:k, <span class="attribute">sep</span>=<span class="string">""</span>),</span><br><span class="line">	<span class="attribute">pch</span>=15, pt.<span class="attribute">cex</span>=2, <span class="attribute">col</span>=2:(k+1), <span class="attribute">bty</span>=<span class="string">"n"</span>)#在图上任意点击某一处放置图例</span><br></pre></td></tr></table></figure>
<p>29.fuzzy.pcoa<img src="https://github.com/ItsYunmeng/MyPostImages/raw/master/NumericalEcologywithR-4-clustering/29.fuzzy.pcoa.png" alt="29"><br>
虽然“硬”聚类产生的分类结果往往不太符合自然界真实的情况，但在需要明确区分对象时，硬聚类的结果很有用。相比之下，模糊聚类在描述对象归类时更加谨慎，也更贴近自然界的实际情况。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/R/" rel="tag"># R</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/20/NumericalEcologywithR-3-associationmeasuresandmatrix/" rel="prev" title="笔记_数量生态学_3.关联测度与矩阵">
      <i class="fa fa-chevron-left"></i> 笔记_数量生态学_3.关联测度与矩阵
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/24/NumericalEcologywithR-5-unconstrainedordination/" rel="next" title="笔记_数量生态学_5.非约束排序">
      笔记_数量生态学_5.非约束排序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">2.</span> <span class="nav-text">聚类概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">3.</span> <span class="nav-text">基于连接的层次聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单连接聚合聚类"><span class="nav-number">3.1.</span> <span class="nav-text">单连接聚合聚类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完全连接聚合聚类"><span class="nav-number">3.2.</span> <span class="nav-text">完全连接聚合聚类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">4.</span> <span class="nav-text">平均聚合聚类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">5.</span> <span class="nav-text">Ward最小方差聚类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">6.</span> <span class="nav-text">灵活聚类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">7.</span> <span class="nav-text">解读和比较层次聚类结果</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">7.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同表型相关"><span class="nav-number">7.2.</span> <span class="nav-text">同表型相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寻找可解读的聚类簇"><span class="nav-number">7.3.</span> <span class="nav-text">寻找可解读的聚类簇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#融合水平值图"><span class="nav-number">7.3.1.</span> <span class="nav-text">融合水平值图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮廓宽度图"><span class="nav-number">7.3.2.</span> <span class="nav-text">轮廓宽度图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#距离矩阵和代表分组的二元矩阵的比较"><span class="nav-number">7.3.3.</span> <span class="nav-text">距离矩阵和代表分组的二元矩阵的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最终分组的轮廓图"><span class="nav-number">7.3.4.</span> <span class="nav-text">最终分组的轮廓图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用绘图工具修饰的最终聚类树"><span class="nav-number">7.3.5.</span> <span class="nav-text">利用绘图工具修饰的最终聚类树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚类结果空间分布图"><span class="nav-number">7.3.6.</span> <span class="nav-text">聚类结果空间分布图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#热图和排序的群落表"><span class="nav-number">7.3.7.</span> <span class="nav-text">热图和排序的群落表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">8.</span> <span class="nav-text">非层次聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#k-均值划分"><span class="nav-number">8.1.</span> <span class="nav-text">k-均值划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#围绕中心点划分（PAM）"><span class="nav-number">8.2.</span> <span class="nav-text">围绕中心点划分（PAM）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">9.</span> <span class="nav-text">用环境数据进行比较</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用外部数据进行类型比较（方差分析途径）"><span class="nav-number">9.1.</span> <span class="nav-text">用外部数据进行类型比较（方差分析途径）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双类型比较（列联表分析）"><span class="nav-number">9.2.</span> <span class="nav-text">双类型比较（列联表分析）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">10.</span> <span class="nav-text">物种集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组内数据简单统计：平均多度"><span class="nav-number">10.1.</span> <span class="nav-text">组内数据简单统计：平均多度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kendall共性系数（W）"><span class="nav-number">10.2.</span> <span class="nav-text">Kendall共性系数（W）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于有-无数据的物种集合"><span class="nav-number">10.3.</span> <span class="nav-text">基于有-无数据的物种集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IndVal：物种指示值"><span class="nav-number">10.4.</span> <span class="nav-text">IndVal：物种指示值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">11.</span> <span class="nav-text">多元回归树：约束聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言-2"><span class="nav-number">11.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算（原理）"><span class="nav-number">11.2.</span> <span class="nav-text">计算（原理）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据约束划分"><span class="nav-number">11.2.1.</span> <span class="nav-text">数据约束划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉验证和回归树的裁剪"><span class="nav-number">11.2.2.</span> <span class="nav-text">交叉验证和回归树的裁剪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用mvpart和MVPARTwrap程序包运行MRT"><span class="nav-number">11.3.</span> <span class="nav-text">使用mvpart和MVPARTwrap程序包运行MRT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合MRT和IndVal"><span class="nav-number">11.4.</span> <span class="nav-text">组合MRT和IndVal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作为时序性（chronological）聚类方法的MRT"><span class="nav-number">11.5.</span> <span class="nav-text">作为时序性（chronological）聚类方法的MRT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">12.</span> <span class="nav-text">另类途径：模糊聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用cluster程序包内fanny-函数进行c-均值模糊聚类"><span class="nav-number">12.1.</span> <span class="nav-text">使用cluster程序包内fanny()函数进行c-均值模糊聚类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yunmeng"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yunmeng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ItsYunmeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ItsYunmeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ItsYunmeng" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ItsYunmeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/itsyunmeng" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;itsyunmeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yunmengli@hotmail.com" title="E-Mail → mailto:yunmengli@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yunmeng</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
